{
  "cacheItemsMap": {
    "a-communication-hub-for-two-way-host-remote-bindings/a-communication-hub-for-two-way-host-remote-bindings.mdx": {
      "document": {
        "title": "A communication hub for two way host-remote bindings",
        "summary": "By the end of this article, you will have an idea of how to build a “communication infrastructure” that connects MFEs together. My proposal is a way for MFEs to communicate with each other and with the app-shell in a non-dependent manner. This proposal enables MFEs to communicate with each other and the app-shell more effectively.",
        "publishedDate": "2023-09-02T00:00:00.000Z",
        "tags": [
          "micro-frontends",
          "react"
        ],
        "category": "react",
        "body": {
          "raw": "\n> The term Micro Frontends first came up in ThoughtWorks Technology Radar at the end of 2016. It extends the concepts of micro services to the frontend world. The current trend is to build a feature-rich and powerful browser application, aka single page app, which sits on top of a micro service architecture. Over time the frontend layer, often developed by a separate team, grows and gets more difficult to maintain. That’s what we call a Frontend Monolith.\n>\n> from micro-frontends.org\n\nBy the end of this article, you will have an idea of how to build a “communication infrastructure” that connects MFEs together. My proposal is a way for MFEs to communicate with each other and with the app-shell in a non-dependent manner. This proposal enables MFEs to communicate with each other and the app-shell more effectively.\n\nAll sample codes are Pseudocode. They are just for showing proposed idea. They are not intended to be used in a real application.\n\n### What is the problem being addressed?\n\nAs you move forward, you will encounter many isolated MFEs that you need to combine into a larger container, which I call the app-shell. The big deal is that MFEs need to borrow certain functionalities from their app-shell. For instance, you set up your toaster in the app-shell. Other MFEs, when integrated, use that toaster to display toast messages. From another perspective, putting so much logic into app-shell makes it a fat. Changing the app-shell would be a nightmare at the end of the day.\n\n### What is the solution to this problem?\n\nKeeping app-shell as minimal as possible is the ultimate goal. However, we need to have a way of implementing generic functions such as toast, confirm, etc. Somewhere else, rather than app-shell.\n\n### Prerequisites\n\n- You need to be familiar with frontend development\n- You need to have a basic understanding of react\n- You need to be able to think about micro frontend architecture\n- You are familiar with state management libraries such zustand\n\n### Part 0: What are host and remote\n\nI assume you are familiar with micro frontend terms. However, here’s a quick note about host and remote. Both are standalone applications that can be run independently. They have their own package.json with essential scripts. So, regardless of any circumstances, you can start/develop them.\n\nFrom another point of view, although remote applications are standalone, there should be some kind of container that puts all these remotes together, which we call the host.\n\nHost or App Shell is a very small - or at least should be small - application that defines layouts, general functionalities such as notifications, and handles routing.\n\n-- image 1\n\n### Part 1: What does not work\n\nWith the above explanation in mind, we will now look into one part of app-shell, which displays toast messages. As explained earlier, all other remotes (MFEs) will be consolidated in app-shell. Therefore, something like a toaster should be implemented in a central location that all other remotes can access, such as app-shell. However, putting it into app-shell could make it more susceptible to future changes.\n\nFor a few minutes, let’s try not to separate the toaster from the app-shell. We are going to do the wrong thing. Let's assume we have two primary components implemented in the app-shell, toaster and confirm.\n\n```javascript\n// app_shell/toaster\nfunction Toast({ message }) {\n  return <ToastMessage message={message} />;\n}\nfunction useToast() {\n  return {\n    showSuccess() {\n      /* show toast with success message */\n    },\n    showError() {\n      /* show toast with error message */\n    },\n  };\n}\n\n// app_shell/confirm\nfunction Confirm({ message }) {\n  return <ConfirmMessage message={message} />;\n}\nfunction useConfirm() {\n  return {\n    show() {\n      /* show confirm */\n    },\n  };\n}\n```\n\nSo app-shell will be shipped with these two components. Other MFEs would use these components by communicating with app-shell.\n\n```javascript\n// authentication\nimport { useToast } from 'app_shell/toaster';\n\nfunction Authentication() {\n\n const toaster = useToast();\n\n useEffect(() => {\n  doSomeAuthenticationStuff()\n   .then(toaster.showSuccess)\n   .catch(toaster.showError)\n }, []);\n};\n\n// user profile\nimport { useToast } from 'app_shell/toaster';\n\nfunction UserProfile() {\n\n const toaster = useToast();\n\n function save() {\n  saveProfile()\n   .then(toaster.showSuccess)\n   .catch(showError);\n }\n\n return (\n  <>\n   <h1>User Profile</h1>\n   <button onClick={}>Save</button>\n  </>\n )\n}\n```\n\nEvery update to each of these components results in an update to the entire app-shell. Every change in the toaster requires a whole end-to-end test on app-shell functions. We are making app-shell vulnerable to more bugs and side effects. On the other side, remotes have a direct dependency on app-shell.\n\n### Part 2: What works\n\nSo how are we going to decouple app-shell from such components that bring fragility? First, showing a toast message should not be a direct call. Second, managing the state of the toaster should be handled somewhere rather than app-shell.\n\nFor building an in-direct manner, I am using a very simple infrastructure which is based on the command design pattern.\n\n> The Command pattern encapsulates actions as objects. Command objects allow for loosely coupled systems by separating the objects that issue a request from the objects that actually process the request. These requests are called events and the code that processes the requests are called event handlers.\n\nAnd another remote will handle the toaster state, which I name it communication-hub.\n\n```javascript\n// hub\nimport { useToast } from \"toast\";\n\nconst commands = {\n  showToast: useToast.getState().showToast,\n};\n\nexport const Hub = {\n  runCommand: (command, payload) => commands[command](payload),\n  useValues,\n};\n\nfunction useValues() {\n  const { toast } = useToast();\n\n  return {\n    toast,\n  };\n}\n```\n\nAs before, toaster will work. However, by decoupling toaster from app-shell we ended up to a more solid app-shell that only changes if it should.\n\nOther remotes still can show toast messages.\n\n```javascript\n// authentication\nimport { Hub } from \"toaster\";\n\nfunction Authentication() {\n  useEffect(() => {\n    doSomeAuthenticationStuff()\n      .then(() => {\n        Hub.runCommand(\"showToast\", \"Succeed\");\n      })\n      .catch((error) => {\n        Hub.runCommand(\"showToast\", `Error, ${error}`);\n      });\n  }, []);\n}\n```\n\nCheck out my [Github repository](https://github.com/sadrzadehsina/micro-frontend-playground/tree/main/communication-pattern) for a working version.\n",
          "html": "<blockquote>\n<p>The term Micro Frontends first came up in ThoughtWorks Technology Radar at the end of 2016. It extends the concepts of micro services to the frontend world. The current trend is to build a feature-rich and powerful browser application, aka single page app, which sits on top of a micro service architecture. Over time the frontend layer, often developed by a separate team, grows and gets more difficult to maintain. That’s what we call a Frontend Monolith.</p>\n<p>from micro-frontends.org</p>\n</blockquote>\n<p>By the end of this article, you will have an idea of how to build a “communication infrastructure” that connects MFEs together. My proposal is a way for MFEs to communicate with each other and with the app-shell in a non-dependent manner. This proposal enables MFEs to communicate with each other and the app-shell more effectively.</p>\n<p>All sample codes are Pseudocode. They are just for showing proposed idea. They are not intended to be used in a real application.</p>\n<h3>What is the problem being addressed?</h3>\n<p>As you move forward, you will encounter many isolated MFEs that you need to combine into a larger container, which I call the app-shell. The big deal is that MFEs need to borrow certain functionalities from their app-shell. For instance, you set up your toaster in the app-shell. Other MFEs, when integrated, use that toaster to display toast messages. From another perspective, putting so much logic into app-shell makes it a fat. Changing the app-shell would be a nightmare at the end of the day.</p>\n<h3>What is the solution to this problem?</h3>\n<p>Keeping app-shell as minimal as possible is the ultimate goal. However, we need to have a way of implementing generic functions such as toast, confirm, etc. Somewhere else, rather than app-shell.</p>\n<h3>Prerequisites</h3>\n<ul>\n<li>You need to be familiar with frontend development</li>\n<li>You need to have a basic understanding of react</li>\n<li>You need to be able to think about micro frontend architecture</li>\n<li>You are familiar with state management libraries such zustand</li>\n</ul>\n<h3>Part 0: What are host and remote</h3>\n<p>I assume you are familiar with micro frontend terms. However, here’s a quick note about host and remote. Both are standalone applications that can be run independently. They have their own package.json with essential scripts. So, regardless of any circumstances, you can start/develop them.</p>\n<p>From another point of view, although remote applications are standalone, there should be some kind of container that puts all these remotes together, which we call the host.</p>\n<p>Host or App Shell is a very small - or at least should be small - application that defines layouts, general functionalities such as notifications, and handles routing.</p>\n<p>-- image 1</p>\n<h3>Part 1: What does not work</h3>\n<p>With the above explanation in mind, we will now look into one part of app-shell, which displays toast messages. As explained earlier, all other remotes (MFEs) will be consolidated in app-shell. Therefore, something like a toaster should be implemented in a central location that all other remotes can access, such as app-shell. However, putting it into app-shell could make it more susceptible to future changes.</p>\n<p>For a few minutes, let’s try not to separate the toaster from the app-shell. We are going to do the wrong thing. Let's assume we have two primary components implemented in the app-shell, toaster and confirm.</p>\n<pre><code class=\"language-javascript\">// app_shell/toaster\nfunction Toast({ message }) {\n  return &#x3C;ToastMessage message={message} />;\n}\nfunction useToast() {\n  return {\n    showSuccess() {\n      /* show toast with success message */\n    },\n    showError() {\n      /* show toast with error message */\n    },\n  };\n}\n\n// app_shell/confirm\nfunction Confirm({ message }) {\n  return &#x3C;ConfirmMessage message={message} />;\n}\nfunction useConfirm() {\n  return {\n    show() {\n      /* show confirm */\n    },\n  };\n}\n</code></pre>\n<p>So app-shell will be shipped with these two components. Other MFEs would use these components by communicating with app-shell.</p>\n<pre><code class=\"language-javascript\">// authentication\nimport { useToast } from 'app_shell/toaster';\n\nfunction Authentication() {\n\n const toaster = useToast();\n\n useEffect(() => {\n  doSomeAuthenticationStuff()\n   .then(toaster.showSuccess)\n   .catch(toaster.showError)\n }, []);\n};\n\n// user profile\nimport { useToast } from 'app_shell/toaster';\n\nfunction UserProfile() {\n\n const toaster = useToast();\n\n function save() {\n  saveProfile()\n   .then(toaster.showSuccess)\n   .catch(showError);\n }\n\n return (\n  &#x3C;>\n   &#x3C;h1>User Profile&#x3C;/h1>\n   &#x3C;button onClick={}>Save&#x3C;/button>\n  &#x3C;/>\n )\n}\n</code></pre>\n<p>Every update to each of these components results in an update to the entire app-shell. Every change in the toaster requires a whole end-to-end test on app-shell functions. We are making app-shell vulnerable to more bugs and side effects. On the other side, remotes have a direct dependency on app-shell.</p>\n<h3>Part 2: What works</h3>\n<p>So how are we going to decouple app-shell from such components that bring fragility? First, showing a toast message should not be a direct call. Second, managing the state of the toaster should be handled somewhere rather than app-shell.</p>\n<p>For building an in-direct manner, I am using a very simple infrastructure which is based on the command design pattern.</p>\n<blockquote>\n<p>The Command pattern encapsulates actions as objects. Command objects allow for loosely coupled systems by separating the objects that issue a request from the objects that actually process the request. These requests are called events and the code that processes the requests are called event handlers.</p>\n</blockquote>\n<p>And another remote will handle the toaster state, which I name it communication-hub.</p>\n<pre><code class=\"language-javascript\">// hub\nimport { useToast } from \"toast\";\n\nconst commands = {\n  showToast: useToast.getState().showToast,\n};\n\nexport const Hub = {\n  runCommand: (command, payload) => commands[command](payload),\n  useValues,\n};\n\nfunction useValues() {\n  const { toast } = useToast();\n\n  return {\n    toast,\n  };\n}\n</code></pre>\n<p>As before, toaster will work. However, by decoupling toaster from app-shell we ended up to a more solid app-shell that only changes if it should.</p>\n<p>Other remotes still can show toast messages.</p>\n<pre><code class=\"language-javascript\">// authentication\nimport { Hub } from \"toaster\";\n\nfunction Authentication() {\n  useEffect(() => {\n    doSomeAuthenticationStuff()\n      .then(() => {\n        Hub.runCommand(\"showToast\", \"Succeed\");\n      })\n      .catch((error) => {\n        Hub.runCommand(\"showToast\", `Error, ${error}`);\n      });\n  }, []);\n}\n</code></pre>\n<p>Check out my <a href=\"https://github.com/sadrzadehsina/micro-frontend-playground/tree/main/communication-pattern\">Github repository</a> for a working version.</p>"
        },
        "_id": "a-communication-hub-for-two-way-host-remote-bindings/a-communication-hub-for-two-way-host-remote-bindings.mdx",
        "_raw": {
          "sourceFilePath": "a-communication-hub-for-two-way-host-remote-bindings/a-communication-hub-for-two-way-host-remote-bindings.mdx",
          "sourceFileName": "a-communication-hub-for-two-way-host-remote-bindings.mdx",
          "sourceFileDir": "a-communication-hub-for-two-way-host-remote-bindings",
          "contentType": "mdx",
          "flattenedPath": "a-communication-hub-for-two-way-host-remote-bindings/a-communication-hub-for-two-way-host-remote-bindings"
        },
        "type": "Post",
        "url": "/posts/a-communication-hub-for-two-way-host-remote-bindings"
      },
      "documentHash": "1697815654088",
      "hasWarnings": false,
      "documentTypeName": "Post"
    },
    "dependency-shadowing/dependency-shadowing.mdx": {
      "document": {
        "title": "Dependency Shadowing",
        "summary": "There are two types of dependencies when you are working with micro-frontends. Runtime and Build-Time. Each of them has its own pros and cons. It is important to choose the one that works in your situation. Basically, both types fix a part of the problem.",
        "publishedDate": "2023-09-23T00:00:00.000Z",
        "tags": [
          "micro-frontend",
          "react"
        ],
        "category": "react",
        "body": {
          "raw": "\nThere are two types of dependencies when you are working with micro-frontends.\n\n- Runtime: These are dependencies that are not included in the initial bundle. When your application runs, all these types of dependencies are loaded on the fly.\n\n- Build-Time: These are dependencies that are bundled when building your application.\n\nEach of them has its own pros and cons. It is important to choose the one that works in your situation. Basically, both types fix a part of the problem.\n\nWhen you need to package a feature, version it, and put it in an NPM-like registry, a build-time dependency works great. On the other side, when you need to have that “on-the-fly-update” kind of behavior, runtime is the choice.\n\nWith all the benefits that build-time dependencies bring, there is one important drawback. Consider that you have multiple MFEs, all requiring a build-time dependency. Changing that dependency results in updating all MFEs, in case they need that change.\n\n-- image 1\n\nThis causes a situation that I name premature MFE update. A condition in which MFE is not ready to deploy but is forced to deploy. It is important because you lose control of what you are deploying.\n\nSo how to fix this? We still need to have build-time dependencies alongside a way of delivering MFEs on purpose.\n\nThis is where dependency-shadowing helps. Consider you have a build-time package called date-helpers. It is responsible for exposing a set of utilities for formatting dates. A few of your MFEs need this. So instead of adding this dependency directly to all MFEs, you can shadow it by creating another MFE called date-helpers-mfe. This latter MFE is just a wrapper that exposes all functions from the original package.\n\n-- image 2\n\nIn this way, the only MFE that needs to be updated every time there is a change in the build-time dependency is this one.\n",
          "html": "<p>There are two types of dependencies when you are working with micro-frontends.</p>\n<ul>\n<li>\n<p>Runtime: These are dependencies that are not included in the initial bundle. When your application runs, all these types of dependencies are loaded on the fly.</p>\n</li>\n<li>\n<p>Build-Time: These are dependencies that are bundled when building your application.</p>\n</li>\n</ul>\n<p>Each of them has its own pros and cons. It is important to choose the one that works in your situation. Basically, both types fix a part of the problem.</p>\n<p>When you need to package a feature, version it, and put it in an NPM-like registry, a build-time dependency works great. On the other side, when you need to have that “on-the-fly-update” kind of behavior, runtime is the choice.</p>\n<p>With all the benefits that build-time dependencies bring, there is one important drawback. Consider that you have multiple MFEs, all requiring a build-time dependency. Changing that dependency results in updating all MFEs, in case they need that change.</p>\n<p>-- image 1</p>\n<p>This causes a situation that I name premature MFE update. A condition in which MFE is not ready to deploy but is forced to deploy. It is important because you lose control of what you are deploying.</p>\n<p>So how to fix this? We still need to have build-time dependencies alongside a way of delivering MFEs on purpose.</p>\n<p>This is where dependency-shadowing helps. Consider you have a build-time package called date-helpers. It is responsible for exposing a set of utilities for formatting dates. A few of your MFEs need this. So instead of adding this dependency directly to all MFEs, you can shadow it by creating another MFE called date-helpers-mfe. This latter MFE is just a wrapper that exposes all functions from the original package.</p>\n<p>-- image 2</p>\n<p>In this way, the only MFE that needs to be updated every time there is a change in the build-time dependency is this one.</p>"
        },
        "_id": "dependency-shadowing/dependency-shadowing.mdx",
        "_raw": {
          "sourceFilePath": "dependency-shadowing/dependency-shadowing.mdx",
          "sourceFileName": "dependency-shadowing.mdx",
          "sourceFileDir": "dependency-shadowing",
          "contentType": "mdx",
          "flattenedPath": "dependency-shadowing/dependency-shadowing"
        },
        "type": "Post",
        "url": "/posts/dependency-shadowing"
      },
      "documentHash": "1697818287424",
      "hasWarnings": false,
      "documentTypeName": "Post"
    }
  }
}
