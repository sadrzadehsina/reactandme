{
  "title": "Dependency Shadowing",
  "summary": "There are two types of dependencies when you are working with micro-frontends. Runtime and Build-Time. Each of them has its own pros and cons. It is important to choose the one that works in your situation. Basically, both types fix a part of the problem.",
  "publishedDate": "2023-09-23T00:00:00.000Z",
  "tags": [
    "micro-frontend",
    "react"
  ],
  "category": "react",
  "body": {
    "raw": "\nThere are two types of dependencies when you are working with micro-frontends.\n\n- Runtime: These are dependencies that are not included in the initial bundle. When your application runs, all these types of dependencies are loaded on the fly.\n\n- Build-Time: These are dependencies that are bundled when building your application.\n\nEach of them has its own pros and cons. It is important to choose the one that works in your situation. Basically, both types fix a part of the problem.\n\nWhen you need to package a feature, version it, and put it in an NPM-like registry, a build-time dependency works great. On the other side, when you need to have that “on-the-fly-update” kind of behavior, runtime is the choice.\n\nWith all the benefits that build-time dependencies bring, there is one important drawback. Consider that you have multiple MFEs, all requiring a build-time dependency. Changing that dependency results in updating all MFEs, in case they need that change.\n\n<Image src=\"/dependency-shadowing/1.webp\" alt=\"figure-1\" />\n\nThis causes a situation that I name premature MFE update. A condition in which MFE is not ready to deploy but is forced to deploy. It is important because you lose control of what you are deploying.\n\nSo how to fix this? We still need to have build-time dependencies alongside a way of delivering MFEs on purpose.\n\nThis is where dependency-shadowing helps. Consider you have a build-time package called date-helpers. It is responsible for exposing a set of utilities for formatting dates. A few of your MFEs need this. So instead of adding this dependency directly to all MFEs, you can shadow it by creating another MFE called date-helpers-mfe. This latter MFE is just a wrapper that exposes all functions from the original package.\n\n<Image src=\"/dependency-shadowing/2.webp\" alt=\"figure-2\" />\n\nIn this way, the only MFE that needs to be updated every time there is a change in the build-time dependency is this one.\n",
    "code": "var Component=(()=>{var c=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var i in e)a(n,i,{get:e[i],enumerable:!0})},s=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!m.call(n,o)&&o!==i&&a(n,o,{get:()=>e[o],enumerable:!(r=p(e,o))||r.enumerable});return n};var w=(n,e,i)=>(i=n!=null?c(y(n)):{},s(e||!n||!n.__esModule?a(i,\"default\",{value:n,enumerable:!0}):i,n)),b=n=>s(a({},\"__esModule\",{value:!0}),n);var h=f((v,d)=>{d.exports=_jsx_runtime});var F={};g(F,{default:()=>E,frontmatter:()=>x});var t=w(h()),x={title:\"Dependency Shadowing\",summary:\"There are two types of dependencies when you are working with micro-frontends. Runtime and Build-Time. Each of them has its own pros and cons. It is important to choose the one that works in your situation. Basically, both types fix a part of the problem.\",publishedDate:new Date(16954272e5),tags:[\"micro-frontend\",\"react\"]};function l(n){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\"},n.components),{Image:i}=e;return i||k(\"Image\",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"There are two types of dependencies when you are working with micro-frontends.\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"Runtime: These are dependencies that are not included in the initial bundle. When your application runs, all these types of dependencies are loaded on the fly.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"Build-Time: These are dependencies that are bundled when building your application.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Each of them has its own pros and cons. It is important to choose the one that works in your situation. Basically, both types fix a part of the problem.\"}),`\n`,(0,t.jsx)(e.p,{children:\"When you need to package a feature, version it, and put it in an NPM-like registry, a build-time dependency works great. On the other side, when you need to have that \\u201Con-the-fly-update\\u201D kind of behavior, runtime is the choice.\"}),`\n`,(0,t.jsx)(e.p,{children:\"With all the benefits that build-time dependencies bring, there is one important drawback. Consider that you have multiple MFEs, all requiring a build-time dependency. Changing that dependency results in updating all MFEs, in case they need that change.\"}),`\n`,(0,t.jsx)(i,{src:\"/dependency-shadowing/1.webp\",alt:\"figure-1\"}),`\n`,(0,t.jsx)(e.p,{children:\"This causes a situation that I name premature MFE update. A condition in which MFE is not ready to deploy but is forced to deploy. It is important because you lose control of what you are deploying.\"}),`\n`,(0,t.jsx)(e.p,{children:\"So how to fix this? We still need to have build-time dependencies alongside a way of delivering MFEs on purpose.\"}),`\n`,(0,t.jsx)(e.p,{children:\"This is where dependency-shadowing helps. Consider you have a build-time package called date-helpers. It is responsible for exposing a set of utilities for formatting dates. A few of your MFEs need this. So instead of adding this dependency directly to all MFEs, you can shadow it by creating another MFE called date-helpers-mfe. This latter MFE is just a wrapper that exposes all functions from the original package.\"}),`\n`,(0,t.jsx)(i,{src:\"/dependency-shadowing/2.webp\",alt:\"figure-2\"}),`\n`,(0,t.jsx)(e.p,{children:\"In this way, the only MFE that needs to be updated every time there is a change in the build-time dependency is this one.\"})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var E=M;function k(n,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+n+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return b(F);})();\n;return Component;"
  },
  "_id": "dependency-shadowing/dependency-shadowing.mdx",
  "_raw": {
    "sourceFilePath": "dependency-shadowing/dependency-shadowing.mdx",
    "sourceFileName": "dependency-shadowing.mdx",
    "sourceFileDir": "dependency-shadowing",
    "contentType": "mdx",
    "flattenedPath": "dependency-shadowing/dependency-shadowing"
  },
  "type": "Post",
  "url": "/posts/dependency-shadowing"
}